{
  "version": 3,
  "sources": ["../../node_modules/serialize-query-params/src/withDefault.ts", "../../node_modules/serialize-query-params/src/serialize.ts", "../../node_modules/serialize-query-params/src/params.ts", "../../node_modules/serialize-query-params/src/objectToSearchString.ts", "../../node_modules/serialize-query-params/src/updateLocation.ts", "../../node_modules/serialize-query-params/src/encodeQueryParams.ts", "../../node_modules/serialize-query-params/src/decodeQueryParams.ts", "../../node_modules/serialize-query-params/src/searchStringToObject.ts", "../../node_modules/use-query-params/src/useQueryParam.ts", "../../node_modules/use-query-params/src/useQueryParams.ts", "../../node_modules/use-query-params/src/decodedParamCache.ts", "../../node_modules/use-query-params/src/inheritedParams.ts", "../../node_modules/use-query-params/src/shallowEqual.ts", "../../node_modules/use-query-params/src/latestValues.ts", "../../node_modules/use-query-params/src/urlName.ts", "../../node_modules/use-query-params/src/memoSearchStringToObject.ts", "../../node_modules/use-query-params/src/options.ts", "../../node_modules/use-query-params/src/QueryParamProvider.tsx", "../../node_modules/use-query-params/src/removeDefaults.ts", "../../node_modules/use-query-params/src/updateSearchString.ts", "../../node_modules/use-query-params/src/withQueryParams.tsx", "../../node_modules/use-query-params/src/QueryParams.tsx"],
  "sourcesContent": ["import { QueryParamConfig } from './types';\n\n/**\n * Wrap a given parameter with a default value when undefined or null (optionally, default includes null)\n * @param param QueryParamConfig - { encode, decode} to serialize a parameter\n * @param defaultValue A default value\n * @param includeNull\n */\nexport function withDefault<D, DefaultType extends D2, D2 = D>(\n  param: QueryParamConfig<D, D2>,\n  defaultValue: DefaultType,\n  includeNull?: false | undefined\n): QueryParamConfig<D, Exclude<D2, undefined> | DefaultType>;\nexport function withDefault<D, DefaultType extends D2, D2 = D>(\n  param: QueryParamConfig<D, D2>,\n  defaultValue: DefaultType,\n  includeNull?: true\n): QueryParamConfig<D, Exclude<D2, null | undefined> | DefaultType>;\nexport function withDefault<D, DefaultType extends D2, D2 = D>(\n  param: QueryParamConfig<D, D2>,\n  defaultValue: DefaultType,\n  includeNull: boolean = true\n): QueryParamConfig<D, any | DefaultType> {\n  const decodeWithDefault = (\n    ...args: Parameters<typeof param.decode>\n  ): Exclude<D2, null | undefined> | Exclude<D2, undefined> | DefaultType => {\n    const decodedValue = param.decode(...args);\n\n    if (decodedValue === undefined) {\n      return defaultValue;\n    }\n    if (includeNull) {\n      if (decodedValue === null) {\n        return defaultValue;\n      } else {\n        return decodedValue as Exclude<D2, undefined>;\n      }\n    }\n\n    return decodedValue as Exclude<D2, undefined | null>;\n  };\n\n  // note we add `default` into the param for other tools to introspect\n  return { ...param, default: defaultValue, decode: decodeWithDefault };\n}\nexport default withDefault;\n", "/**\n * Interprets an encoded string and returns either the string or null/undefined if not available.\n * Ignores array inputs (takes just first element in array)\n * @param input encoded string\n */\nfunction getEncodedValue(\n  input: string | (string | null)[] | null | undefined,\n  allowEmptyString?: boolean\n): string | null | undefined {\n  if (input == null) {\n    return input;\n  }\n  // '' or []\n  if (\n    input.length === 0 &&\n    (!allowEmptyString || (allowEmptyString && input !== ''))\n  ) {\n    return null;\n  }\n\n  const str = input instanceof Array ? input[0] : input;\n  if (str == null) {\n    return str;\n  }\n  if (!allowEmptyString && str === '') {\n    return null;\n  }\n\n  return str;\n}\n\n/**\n * Interprets an encoded string and return null/undefined or an array with\n * the encoded string contents\n * @param input encoded string\n */\nfunction getEncodedValueArray(\n  input: string | (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (input == null) {\n    return input;\n  }\n\n  return input instanceof Array ? input : input === '' ? [] : [input];\n}\n\n/**\n * Encodes a date as a string in YYYY-MM-DD format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDate(\n  date: Date | null | undefined\n): string | null | undefined {\n  if (date == null) {\n    return date;\n  }\n\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n\n  return `${year}-${month < 10 ? `0${month}` : month}-${\n    day < 10 ? `0${day}` : day\n  }`;\n}\n\n/**\n * Converts a date in the format 'YYYY-mm-dd...' into a proper date, because\n * new Date() does not do that correctly. The date can be as complete or incomplete\n * as necessary (aka, '2015', '2015-10', '2015-10-01').\n * It will not work for dates that have times included in them.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '2015-10-01'\n * @return {Date} parsed date\n */\nexport function decodeDate(\n  input: string | (string | null)[] | null | undefined\n): Date | null | undefined {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n\n  const parts = dateString.split('-') as any;\n  // may only be a year so won't even have a month\n  if (parts[1] != null) {\n    parts[1] -= 1; // Note: months are 0-based\n  } else {\n    // just a year, set the month and day to the first\n    parts[1] = 0;\n    parts[2] = 1;\n  }\n\n  const decoded = new Date(...(parts as [number, number, number]));\n\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n\n  return decoded;\n}\n\n/**\n * Encodes a date as a string in ISO 8601 (\"2019-05-28T10:58:40Z\") format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDateTime(\n  date: Date | null | undefined\n): string | null | undefined {\n  if (date == null) {\n    return date;\n  }\n\n  return date.toISOString();\n}\n\n/**\n * Converts a date in the https://en.wikipedia.org/wiki/ISO_8601 format.\n * For allowed inputs see specs:\n *  - https://tools.ietf.org/html/rfc2822#page-14\n *  - http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '1995-12-17T03:24:00'\n * @return {Date} parsed date\n */\nexport function decodeDateTime(\n  input: string | (string | null)[] | null | undefined\n): Date | null | undefined {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n\n  const decoded = new Date(dateString);\n\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n\n  return decoded;\n}\n\n/**\n * Encodes a boolean as a string. true -> \"1\", false -> \"0\".\n *\n * @param {Boolean} bool\n * @return {String} the encoded boolean\n */\nexport function encodeBoolean(\n  bool: boolean | null | undefined\n): string | null | undefined {\n  if (bool == null) {\n    return bool;\n  }\n\n  return bool ? '1' : '0';\n}\n\n/**\n * Decodes a boolean from a string. \"1\" -> true, \"0\" -> false.\n * Everything else maps to undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded boolean string\n * @return {Boolean} the boolean value\n */\nexport function decodeBoolean(\n  input: string | (string | null)[] | null | undefined\n): boolean | null | undefined {\n  const boolStr = getEncodedValue(input);\n  if (boolStr == null) return boolStr;\n\n  if (boolStr === '1') {\n    return true;\n  } else if (boolStr === '0') {\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Encodes a number as a string.\n *\n * @param {Number} num\n * @return {String} the encoded number\n */\nexport function encodeNumber(\n  num: number | null | undefined\n): string | null | undefined {\n  if (num == null) {\n    return num;\n  }\n\n  return String(num);\n}\n\n/**\n * Decodes a number from a string. If the number is invalid,\n * it returns undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded number string\n * @return {Number} the number value\n */\nexport function decodeNumber(\n  input: string | (string | null)[] | null | undefined\n): number | null | undefined {\n  const numStr = getEncodedValue(input);\n  if (numStr == null) return numStr;\n  if (numStr === '') return null;\n\n  const result = +numStr;\n  return result;\n}\n\n/**\n * Encodes a string while safely handling null and undefined values.\n *\n * @param {String} str a string to encode\n * @return {String} the encoded string\n */\nexport function encodeString(\n  str: string | (string | null)[] | null | undefined\n): string | null | undefined {\n  if (str == null) {\n    return str;\n  }\n\n  return String(str);\n}\n\n/**\n * Decodes a string while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @return {String} the string value\n */\nexport function decodeString(\n  input: string | (string | null)[] | null | undefined\n): string | null | undefined {\n  const str = getEncodedValue(input, true);\n  if (str == null) return str;\n\n  return String(str);\n}\n\n/**\n * Decodes an enum value while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @param {String[]} enumValues allowed enum values\n * @return {String} the string value from enumValues\n */\nexport function decodeEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[]\n): T | null | undefined {\n  const str = decodeString(input);\n  if (str == null) return str;\n  return enumValues.includes(str as any) ? (str as T) : undefined;\n}\n\n/**\n * Decodes an enum value from arrays while safely handling null and undefined values.\n *\n * @template T\n * @param {String} input the encoded string\n * @param {T[]} enumValues allowed enum values\n * @return {T[]} the string value from enumValues\n */\nexport function decodeArrayEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[]\n): T[] | null | undefined {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n  if (!arr.length) return undefined;\n  return arr.every((str) => str != null && enumValues.includes(str as T))\n    ? (arr as T[])\n    : undefined;\n}\n\n/**\n * Decodes an enum value from arrays while safely handling null and undefined values.\n *\n * @template T\n * @param {String} input the encoded string\n * @param {T[]} enumValues allowed enum values\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {T[]} the string value from enumValues\n */\nexport function decodeDelimitedArrayEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[],\n  entrySeparator = '_'\n): T[] | null | undefined {\n  if (input != null && Array.isArray(input) && !input.length) return undefined;\n  const arr = decodeDelimitedArray(input, entrySeparator);\n  return decodeArrayEnum(arr, enumValues);\n}\n\n/**\n * Encodes anything as a JSON string.\n *\n * @param {Any} any The thing to be encoded\n * @return {String} The JSON string representation of any\n */\nexport function encodeJson(\n  any: any | null | undefined\n): string | null | undefined {\n  if (any == null) {\n    return any;\n  }\n\n  return JSON.stringify(any);\n}\n\n/**\n * Decodes a JSON string into javascript\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @return {Any} The javascript representation\n */\nexport function decodeJson(\n  input: string | (string | null)[] | null | undefined\n): any | null | undefined {\n  const jsonStr = getEncodedValue(input);\n  if (jsonStr == null) return jsonStr;\n\n  let result = null;\n  try {\n    result = JSON.parse(jsonStr);\n  } catch (e) {\n    /* ignore errors, returning undefined */\n  }\n\n  return result;\n}\n\n/**\n * Encodes an array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeArray(\n  array: (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array;\n}\n\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeArray(\n  input: string | (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  const arr = getEncodedValueArray(input);\n  if (arr == null) return arr;\n\n  return arr;\n}\n\n/**\n * Encodes a numeric array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeNumericArray(\n  array: (number | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.map(String);\n}\n\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined and NaN values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeNumericArray(\n  input: string | (string | null)[] | null | undefined\n): (number | null)[] | null | undefined {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n\n  return arr.map((d) => (d === '' || d == null ? null : +d));\n}\n\n/**\n * Encodes an array as a delimited string. For example,\n * ['a', 'b'] -> 'a_b' with entrySeparator='_'\n *\n * @param array The array to be encoded\n * @param entrySeparator The string used to delimit entries\n * @return The array as a string with elements joined by the\n * entry separator\n */\nexport function encodeDelimitedArray(\n  array: (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): string | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.join(entrySeparator);\n}\n\n/**\n * Decodes a delimited string into javascript array. For example,\n * 'a_b' -> ['a', 'b'] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedArray(\n  input: string | (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): (string | null)[] | null | undefined {\n  const arrayStr = getEncodedValue(input, true);\n  if (arrayStr == null) return arrayStr;\n  if (arrayStr === '') return [];\n\n  return arrayStr.split(entrySeparator);\n}\n\n/**\n * Encodes a numeric array as a delimited string. (alias of encodeDelimitedArray)\n * For example, [1, 2] -> '1_2' with entrySeparator='_'\n *\n * @param {Array} array The array to be encoded\n * @return {String} The JSON string representation of array\n */\nexport const encodeDelimitedNumericArray = encodeDelimitedArray as (\n  array: (number | null)[] | null | undefined,\n  entrySeparator?: string\n) => string | null | undefined;\n\n/**\n * Decodes a delimited string into javascript array where all entries are numbers\n * For example, '1_2' -> [1, 2] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} jsonStr The JSON string representation\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedNumericArray(\n  arrayStr: string | (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): (number | null)[] | null | undefined {\n  const decoded = decodeDelimitedArray(arrayStr, entrySeparator);\n  if (decoded == null) return decoded;\n\n  return decoded.map((d) => (d === '' || d == null ? null : +d));\n}\n\n/**\n * Encode simple objects as readable strings. Works only for simple,\n * flat objects where values are numbers, strings.\n *\n * For example { foo: bar, boo: baz } -> \"foo-bar_boo-baz\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport function encodeObject(\n  obj: { [key: string]: string | null | number | undefined } | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): string | null | undefined {\n  if (obj == null) return obj; // null or undefined\n  if (!Object.keys(obj).length) return ''; // {} case\n\n  return Object.keys(obj)\n    .map((key) => `${key}${keyValSeparator}${obj[key]}`)\n    .join(entrySeparator);\n}\n\n/**\n * Decodes a simple object to javascript. Currently works only for simple,\n * flat objects where values are strings.\n *\n * For example \"foo-bar_boo-baz\" -> { foo: bar, boo: baz }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeObject(\n  input: string | (string | null)[] | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): { [key: string]: string } | null | undefined {\n  const objStr = getEncodedValue(input, true);\n  if (objStr == null) return objStr;\n  if (objStr === '') return {};\n\n  const obj: { [key: string]: string } = {};\n\n  const keyValSeparatorRegExp = new RegExp(`${keyValSeparator}(.*)`);\n  objStr.split(entrySeparator).forEach((entryStr) => {\n    const [key, value] = entryStr.split(keyValSeparatorRegExp);\n    obj[key] = value;\n  });\n\n  return obj;\n}\n\n/**\n * Encode simple objects as readable strings. Alias of encodeObject.\n *\n * For example { foo: 123, boo: 521 } -> \"foo-123_boo-521\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport const encodeNumericObject = encodeObject as (\n  obj: { [key: string]: number | null | undefined } | null | undefined,\n  keyValSeparator?: string,\n  entrySeparator?: string\n) => string | null | undefined;\n\n/**\n * Decodes a simple object to javascript where all values are numbers.\n * Currently works only for simple, flat objects.\n *\n * For example \"foo-123_boo-521\" -> { foo: 123, boo: 521 }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeNumericObject(\n  input: string | (string | null)[] | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): { [key: string]: number | null | undefined } | null | undefined {\n  const decoded: { [key: string]: string } | null | undefined = decodeObject(\n    input,\n    keyValSeparator,\n    entrySeparator\n  );\n\n  if (decoded == null) return decoded;\n\n  // convert to numbers\n  const decodedNumberObj: { [key: string]: number | null | undefined } = {};\n  for (const key of Object.keys(decoded)) {\n    decodedNumberObj[key] = decodeNumber(decoded[key]);\n  }\n\n  return decodedNumberObj;\n}\n", "import * as Serialize from './serialize';\nimport { QueryParamConfig } from './types';\n\n/**\n * String values\n */\nexport const StringParam: QueryParamConfig<\n  string | null | undefined,\n  string | null | undefined\n> = {\n  encode: Serialize.encodeString,\n  decode: Serialize.decodeString,\n};\n\n/**\n * String enum\n */\nexport const createEnumParam = <T extends string>(\n  enumValues: T[]\n): QueryParamConfig<T | null | undefined, T | null | undefined> => ({\n  encode: Serialize.encodeString,\n  decode: (input) => Serialize.decodeEnum(input, enumValues),\n});\n\n/**\n * Array enum\n */\nexport const createEnumArrayParam = <T extends string>(\n  enumValues: T[]\n): QueryParamConfig<T[] | null | undefined, T[] | null | undefined> => ({\n  encode: (text) =>\n    Serialize.encodeArray(text == null || Array.isArray(text) ? text : [text]),\n  decode: (input) => Serialize.decodeArrayEnum(input, enumValues),\n});\n\n/**\n * Array delimited enum\n */\nexport const createEnumDelimitedArrayParam = <T extends string>(\n  enumValues: T[],\n  entrySeparator = '_'\n): QueryParamConfig<T[] | null | undefined, T[] | null | undefined> => ({\n  encode: (text) =>\n    Serialize.encodeDelimitedArray(\n      text == null || Array.isArray(text) ? text : [text],\n      entrySeparator\n    ),\n  decode: (input) =>\n    Serialize.decodeDelimitedArrayEnum(input, enumValues, entrySeparator),\n});\n\n/**\n * Numbers (integers or floats)\n */\nexport const NumberParam: QueryParamConfig<\n  number | null | undefined,\n  number | null | undefined\n> = {\n  encode: Serialize.encodeNumber,\n  decode: Serialize.decodeNumber,\n};\n\n/**\n * For flat objects where values are strings\n */\nexport const ObjectParam: QueryParamConfig<\n  { [key: string]: string | undefined } | null | undefined,\n  { [key: string]: string | undefined } | null | undefined\n> = {\n  encode: Serialize.encodeObject,\n  decode: Serialize.decodeObject,\n};\n\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport const ArrayParam: QueryParamConfig<\n  (string | null)[] | null | undefined,\n  (string | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeArray,\n  decode: Serialize.decodeArray,\n};\n\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport const NumericArrayParam: QueryParamConfig<\n  (number | null)[] | null | undefined,\n  (number | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeNumericArray,\n  decode: Serialize.decodeNumericArray,\n};\n\n/**\n * For any type of data, encoded via JSON.stringify\n */\nexport const JsonParam: QueryParamConfig<any, any> = {\n  encode: Serialize.encodeJson,\n  decode: Serialize.decodeJson,\n};\n\n/**\n * For simple dates (YYYY-MM-DD)\n */\nexport const DateParam: QueryParamConfig<\n  Date | null | undefined,\n  Date | null | undefined\n> = {\n  encode: Serialize.encodeDate,\n  decode: Serialize.decodeDate,\n  equals: (\n    valueA: Date | null | undefined,\n    valueB: Date | null | undefined\n  ) => {\n    if (valueA === valueB) return true;\n    if (valueA == null || valueB == null) return valueA === valueB;\n\n    // ignore time of day\n    return (\n      valueA.getFullYear() === valueB.getFullYear() &&\n      valueA.getMonth() === valueB.getMonth() &&\n      valueA.getDate() === valueB.getDate()\n    );\n  },\n};\n\n/**\n * For dates in simplified extended ISO format (YYYY-MM-DDTHH:mm:ss.sssZ or \u00B1YYYYYY-MM-DDTHH:mm:ss.sssZ)\n */\nexport const DateTimeParam: QueryParamConfig<\n  Date | null | undefined,\n  Date | null | undefined\n> = {\n  encode: Serialize.encodeDateTime,\n  decode: Serialize.decodeDateTime,\n  equals: (\n    valueA: Date | null | undefined,\n    valueB: Date | null | undefined\n  ) => {\n    if (valueA === valueB) return true;\n    if (valueA == null || valueB == null) return valueA === valueB;\n\n    return valueA.valueOf() === valueB.valueOf();\n  },\n};\n\n/**\n * For boolean values: 1 = true, 0 = false\n */\nexport const BooleanParam: QueryParamConfig<\n  boolean | null | undefined,\n  boolean | null | undefined\n> = {\n  encode: Serialize.encodeBoolean,\n  decode: Serialize.decodeBoolean,\n};\n\n/**\n * For flat objects where the values are numbers\n */\nexport const NumericObjectParam: QueryParamConfig<\n  { [key: string]: number | null | undefined } | null | undefined,\n  { [key: string]: number | null | undefined } | null | undefined\n> = {\n  encode: Serialize.encodeNumericObject,\n  decode: Serialize.decodeNumericObject,\n};\n\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport const DelimitedArrayParam: QueryParamConfig<\n  (string | null)[] | null | undefined,\n  (string | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeDelimitedArray,\n  decode: Serialize.decodeDelimitedArray,\n};\n\n/**\n * For flat arrays where the values are numbers, filters out undefined values during decode\n */\nexport const DelimitedNumericArrayParam: QueryParamConfig<\n  (number | null)[] | null | undefined,\n  (number | null)[] | null | undefined\n> = {\n  encode: Serialize.encodeDelimitedNumericArray,\n  decode: Serialize.decodeDelimitedNumericArray,\n};\n", "import { EncodedQuery } from './types';\n\n/**\n * Default implementation of objectToSearchString powered by URLSearchParams.\n * Does not support null values. Does not prefix with \"?\"\n * This converts an object { foo: '123', bar: 'x' } to a search string `?foo=123&bar=x`\n * This is only a very basic version, you may prefer the advanced versions offered\n * by third party libraries like query-string (\"stringify\") or qs.\n */\nexport function objectToSearchString(encodedParams: EncodedQuery): string {\n  const params = new URLSearchParams();\n  const entries = Object.entries(encodedParams);\n\n  for (const [key, value] of entries) {\n    if (value === undefined) continue;\n    if (value === null) continue;\n\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        params.append(key, item ?? '');\n      }\n    } else {\n      params.append(key, value);\n    }\n  }\n\n  return params.toString();\n}\n", "import { EncodedQuery } from './types';\nimport { objectToSearchString } from './objectToSearchString';\nimport { searchStringToObject } from '.';\n\n/**\n * An example of a transformSearchString function that undoes encoding of\n * common JSON characters that are technically allowed in URLs.\n */\nconst JSON_SAFE_CHARS = `{}[],\":`\n  .split('')\n  .map((d) => [d, encodeURIComponent(d)]);\n\nfunction getHrefFromLocation(location: Location, search: string): string {\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n  let href: string = search;\n\n  if (location.href) {\n      // TODO - implement base option if location.href is relative\n      //  see https://developer.mozilla.org/en-US/docs/Web/API/URL/URL#syntax\n    try {\n      const url = new URL(location.href);\n      href = `${url.origin}${url.pathname}${search}`;\n    } catch (e) {\n      href = '';\n    }\n  }\n\n  return href;\n}\n\nexport function transformSearchStringJsonSafe(searchString: string): string {\n  let str = searchString;\n  for (let [char, code] of JSON_SAFE_CHARS) {\n    str = str.replace(new RegExp('\\\\' + code, 'g'), char);\n  }\n  return str;\n}\n\n/**\n * Update a location, wiping out parameters not included in encodedQuery\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateLocation(\n  encodedQuery: EncodedQuery,\n  location: Location,\n  objectToSearchStringFn = objectToSearchString\n): Location {\n  let encodedSearchString = objectToSearchStringFn(encodedQuery);\n\n  const search = encodedSearchString.length ? `?${encodedSearchString}` : '';\n\n  const newLocation: Location & {\n    key: string;\n    query: EncodedQuery;\n  } = {\n    ...location,\n    key: `${Date.now()}`, // needed for some routers (e.g. react-router)\n    href: getHrefFromLocation(location, search),\n    search,\n    query: encodedQuery, // needed for some routers (e.g. found)\n  };\n\n  return newLocation;\n}\n\n/**\n * Update a location while retaining existing parameters.\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateInLocation(\n  encodedQueryReplacements: EncodedQuery,\n  location: Location,\n  objectToSearchStringFn = objectToSearchString,\n  searchStringToObjectFn = searchStringToObject\n): Location {\n  // explicitly avoid parsing numbers to ensure the\n  // return type has the same shape as EncodeQuery\n  const currQuery = searchStringToObjectFn(location.search);\n\n  const newQuery = {\n    ...currQuery,\n    ...encodedQueryReplacements,\n  };\n\n  return updateLocation(newQuery, location, objectToSearchStringFn);\n}\n", "import { DecodedValueMap, QueryParamConfigMap, EncodedValueMap } from './types';\n\n/**\n * Convert the values in query to strings via the encode functions configured\n * in paramConfigMap\n *\n * @param paramConfigMap Map from query name to { encode, decode } config\n * @param query Query updates mapping param name to decoded value\n */\nexport function encodeQueryParams<QPCMap extends QueryParamConfigMap>(\n  paramConfigMap: QPCMap,\n  query: Partial<DecodedValueMap<QPCMap>>\n): Partial<EncodedValueMap<QPCMap>> {\n  const encodedQuery: Partial<EncodedValueMap<QPCMap>> = {};\n\n  const paramNames = Object.keys(query);\n  for (const paramName of paramNames) {\n    const decodedValue = query[paramName];\n\n    if (!paramConfigMap[paramName]) {\n      // NOTE: we could just not encode it, but it is probably convenient to have\n      // it be included by default as a string type.\n      (encodedQuery as any)[paramName] =\n        decodedValue == null ? decodedValue : String(decodedValue);\n    } else {\n      encodedQuery[paramName as keyof QPCMap] = paramConfigMap[\n        paramName\n      ].encode(query[paramName]);\n    }\n  }\n\n  return encodedQuery;\n}\nexport default encodeQueryParams;\n", "import { DecodedValueMap, QueryParamConfigMap, EncodedValueMap } from './types';\n\n/**\n * Convert the values in query to strings via the encode functions configured\n * in paramConfigMap\n *\n * @param paramConfigMap Map from query name to { encode, decode } config\n * @param query Query updates mapping param name to decoded value\n */\nexport function decodeQueryParams<QPCMap extends QueryParamConfigMap>(\n  paramConfigMap: QPCMap,\n  encodedQuery: Partial<EncodedValueMap<QPCMap>>\n): Partial<DecodedValueMap<QPCMap>> {\n  const decodedQuery: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // iterate over all keys in the config (#30)\n  const paramNames = Object.keys(paramConfigMap);\n\n  // ensure any non configured keys that are in the URL are also included\n  for (const encodedKey of Object.keys(encodedQuery)) {\n    if (paramConfigMap[encodedKey] == null) {\n      paramNames.push(encodedKey);\n    }\n  }\n\n  for (const paramName of paramNames) {\n    const encodedValue = encodedQuery[paramName];\n\n    if (!paramConfigMap[paramName]) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Passing through parameter ${paramName} during decoding since it was not configured.`\n        );\n      }\n\n      // NOTE: we could just not include it, but it is probably convenient to have\n      // it default to be a string type.\n      (decodedQuery as any)[paramName] = encodedValue;\n    } else {\n      decodedQuery[paramName as keyof QPCMap] = paramConfigMap[\n        paramName\n      ].decode(encodedValue as string | (string | null)[] | null);\n    }\n  }\n\n  return decodedQuery;\n}\n", "import { EncodedQuery } from './types';\n\n/**\n * Default implementation of searchStringToObject powered by URLSearchParams\n * This converts a search string like `?foo=123&bar=x` to { foo: '123', bar: 'x' }\n * This is only a very basic version, you may prefer the advanced versions offered\n * by third party libraries like query-string (\"parse\") or qs.\n */\nexport function searchStringToObject(searchString: string): EncodedQuery {\n  const params = new URLSearchParams(searchString);\n  const parsed: EncodedQuery = {};\n  for (let [key, value] of params) {\n    if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n      if (Array.isArray(parsed[key])) {\n        (parsed[key] as string[]).push(value);\n      } else {\n        parsed[key] = [parsed[key] as string, value];\n      }\n    } else {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n", "import { useCallback, useMemo } from 'react';\nimport { QueryParamConfig } from 'serialize-query-params';\nimport { QueryParamOptions } from './options';\nimport { UrlUpdateType } from './types';\nimport useQueryParams from './useQueryParams';\n\ntype NewValueType<D> = D | ((latestValue: D) => D);\n\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'pushIn'.\n */\nexport const useQueryParam = <TypeToEncode, TypeFromDecode = TypeToEncode>(\n  name: string,\n  paramConfig?: QueryParamConfig<TypeToEncode, TypeFromDecode>,\n  options?: QueryParamOptions\n): [\n  TypeFromDecode,\n  (newValue: NewValueType<TypeToEncode>, updateType?: UrlUpdateType) => void\n] => {\n  const paramConfigMap = useMemo(\n    () => ({ [name]: paramConfig ?? 'inherit' }),\n    [name, paramConfig]\n  );\n  const [query, setQuery] = useQueryParams(paramConfigMap, options);\n  const decodedValue = query[name];\n  const setValue = useCallback(\n    (newValue: NewValueType<TypeToEncode>, updateType?: UrlUpdateType) => {\n      if (typeof newValue === 'function') {\n        return setQuery((latestValues) => {\n          const newValueFromLatest = (newValue as Function)(latestValues[name]);\n          return { [name]: newValueFromLatest };\n        }, updateType);\n      }\n      return setQuery({ [name]: newValue } as any, updateType);\n    },\n    [name, setQuery]\n  );\n\n  return [decodedValue, setValue];\n};\n", "import { useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  DecodedValueMap,\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport {\n  extendParamConfigForKeys,\n  convertInheritedParamStringsToParams,\n} from './inheritedParams';\nimport { makeStableGetLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { mergeOptions, QueryParamOptions } from './options';\nimport { useQueryParamContext } from './QueryParamProvider';\nimport {\n  QueryParamConfigMapWithInherit,\n  SetQuery,\n  UrlUpdateType,\n} from './types';\nimport { enqueueUpdate } from './updateSearchString';\nimport { serializeUrlNameMap } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\ntype UseQueryParamsResult<QPCMap extends QueryParamConfigMap> = [\n  DecodedValueMap<QPCMap>,\n  SetQuery<QPCMap>\n];\ntype ExpandInherits<QPCMap extends QueryParamConfigMapWithInherit> = {\n  [ParamName in keyof QPCMap]: QPCMap[ParamName] extends string\n    ? typeof StringParam\n    : QPCMap[ParamName] extends QueryParamConfig<any>\n    ? QPCMap[ParamName]\n    : never;\n};\n\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMap = QueryParamConfigMap\n>(): UseQueryParamsResult<QPCMap>;\nexport function useQueryParams<QPCMap extends QueryParamConfigMapWithInherit>(\n  names: string[],\n  options?: QueryParamOptions\n): UseQueryParamsResult<ExpandInherits<QPCMap>>;\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMapWithInherit,\n  OutputQPCMap extends QueryParamConfigMap = ExpandInherits<QPCMap>\n>(\n  paramConfigMap: QPCMap,\n  options?: QueryParamOptions\n): UseQueryParamsResult<OutputQPCMap>;\nexport function useQueryParams(\n  arg1?: string[] | QueryParamConfigMapWithInherit,\n  arg2?: QueryParamConfig<any> | QueryParamOptions\n): UseQueryParamsResult<any> {\n  const { adapter, options: contextOptions } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n\n  // intepret the overloaded arguments\n  const { paramConfigMap: paramConfigMapWithInherit, options } = parseArguments(\n    arg1,\n    arg2\n  );\n\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n\n  // interpret params that were configured up the chain\n  let paramConfigMap = convertInheritedParamStringsToParams(\n    paramConfigMapWithInherit,\n    mergedOptions\n  );\n\n  // what is the current stringified value?\n  const parsedParams = memoSearchStringToObject(\n    mergedOptions.searchStringToObject,\n    adapter.location.search,\n    serializeUrlNameMap(paramConfigMap) // note we serialize for memo purposes\n  );\n\n  // do we want to include all params from the URL even if not configured?\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(\n      paramConfigMap,\n      Object.keys(parsedParams),\n      mergedOptions.params,\n      StringParam\n    );\n  }\n\n  // run decode on each key\n  const decodedValues = stableGetLatest(\n    parsedParams,\n    paramConfigMap,\n    decodedParamCache\n  );\n\n  // clear out unused values in cache\n  // use string for relatively stable effect dependency\n  const paramKeyString = Object.keys(paramConfigMap).join('\\0');\n  useEffect(() => {\n    const paramNames = paramKeyString.split('\\0');\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n\n  // create a setter for updating multiple query params at once\n  // use a ref for callback dependencies so we don't generate a new one unnecessarily\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions,\n  };\n  const callbackDependenciesRef =\n    useRef<typeof callbackDependencies>(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n\n  // create callback with stable identity\n  const [setQuery] = useState(() => {\n    const setQuery = (\n      changes: ChangesType<DecodedValueMap<any>>,\n      updateType?: UrlUpdateType\n    ) => {\n      // read from a ref so we don't generate new setters each time any change\n      const { adapter, paramConfigMap, options } =\n        callbackDependenciesRef.current!;\n      if (updateType == null) updateType = options.updateType;\n\n      enqueueUpdate(\n        {\n          changes,\n          updateType,\n          currentSearchString: adapter.location.search,\n          paramConfigMap,\n          options,\n          adapter,\n        },\n        { immediate: !options.enableBatching }\n      );\n    };\n\n    return setQuery;\n  });\n\n  return [decodedValues, setQuery];\n}\n\nexport default useQueryParams;\n\nfunction parseArguments(\n  arg1: string[] | QueryParamConfigMapWithInherit | undefined,\n  arg2: QueryParamConfig<any> | QueryParamOptions | undefined\n): {\n  paramConfigMap: QueryParamConfigMapWithInherit;\n  options: QueryParamOptions | undefined;\n} {\n  let paramConfigMap: QueryParamConfigMapWithInherit;\n  let options: QueryParamOptions | undefined;\n\n  if (arg1 === undefined) {\n    // useQueryParams()\n    paramConfigMap = {};\n    options = arg2 as QueryParamOptions | undefined;\n  } else if (Array.isArray(arg1)) {\n    // useQueryParams(['geo', 'other'])\n    // useQueryParams(['geo', 'other'], options)\n    paramConfigMap = Object.fromEntries(\n      arg1.map((key) => [key, 'inherit' as const])\n    );\n    options = arg2 as QueryParamOptions | undefined;\n  } else {\n    // useQueryParams({ geo: NumberParam })\n    // useQueryParams({ geo: NumberParam }, options)\n    paramConfigMap = arg1;\n    options = arg2 as QueryParamOptions | undefined;\n  }\n\n  return { paramConfigMap, options };\n}\n", "type EncodedValue = string | (string | null)[] | null | undefined;\n\ntype CachedParam = {\n  stringified: EncodedValue;\n  decoded: any;\n  decode: Function;\n};\n\n/**\n * simple cache that keeps values around so long as something\n * has registered interest in it (typically via calling useQueryParams).\n * Caches based on the stringified value as the key and the\n * last passed in decode function.\n */\nexport class DecodedParamCache {\n  private paramsMap: Map<string, CachedParam>;\n  private registeredParams: Map<string, number>;\n\n  constructor() {\n    this.paramsMap = new Map();\n    this.registeredParams = new Map();\n  }\n\n  set(\n    param: string,\n    stringifiedValue: EncodedValue,\n    decodedValue: any,\n    decode: Function\n  ) {\n    this.paramsMap.set(param, {\n      stringified: stringifiedValue,\n      decoded: decodedValue,\n      decode,\n    });\n  }\n\n  /**\n   * A param has been cached if the stringified value and decode function matches\n   */\n  has(param: string, stringifiedValue: EncodedValue, decode?: Function) {\n    if (!this.paramsMap.has(param)) return false;\n    const cachedParam = this.paramsMap.get(param);\n    if (!cachedParam) return false;\n\n    return (\n      cachedParam.stringified === stringifiedValue &&\n      (decode == null || cachedParam.decode === decode)\n    );\n  }\n\n  get(param: string) {\n    if (this.paramsMap.has(param)) return this.paramsMap.get(param)?.decoded;\n    return undefined;\n  }\n\n  /**\n   * Register interest in a set of param names. When these go to 0 they are cleaned out.\n   */\n  registerParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const currValue = this.registeredParams.get(param) || 0;\n      this.registeredParams.set(param, currValue + 1);\n    }\n  }\n\n  /**\n   * Unregister interest in a set of param names. If there is no remaining interest,\n   * remove the decoded value from the cache to prevent memory leaks.\n   */\n  unregisterParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const value = (this.registeredParams.get(param) || 0) - 1;\n      if (value <= 0) {\n        this.registeredParams.delete(param);\n        if (this.paramsMap.has(param)) {\n          this.paramsMap.delete(param);\n        }\n      } else {\n        this.registeredParams.set(param, value);\n      }\n    }\n  }\n\n  clear() {\n    this.paramsMap.clear();\n    this.registeredParams.clear();\n  }\n}\n\nexport const decodedParamCache = new DecodedParamCache();\n", "import {\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { QueryParamOptions } from './options';\nimport { QueryParamConfigMapWithInherit } from './types';\n\n/**\n * Convert inherit strings from a query param config to actual\n * parameters based on predefined ('inherited') mappings.\n * Defaults to StringParam.\n */\nexport function convertInheritedParamStringsToParams(\n  paramConfigMapWithInherit: QueryParamConfigMapWithInherit,\n  options: QueryParamOptions\n): QueryParamConfigMap {\n  const paramConfigMap: QueryParamConfigMap = {};\n  let hasInherit = false;\n\n  const hookKeys = Object.keys(paramConfigMapWithInherit);\n  let paramKeys = hookKeys;\n\n  // include known params if asked for explicitly, or no params were configured and we didn't\n  // explicitly say not to\n  const includeKnownParams =\n    options.includeKnownParams ||\n    (options.includeKnownParams !== false && hookKeys.length === 0);\n\n  if (includeKnownParams) {\n    const knownKeys = Object.keys(options.params ?? {});\n    paramKeys.push(...knownKeys);\n  }\n\n  for (const key of paramKeys) {\n    const param = paramConfigMapWithInherit[key];\n    // does it have an existing parameter definition? use it\n    if (param != null && typeof param === 'object') {\n      paramConfigMap[key] = param;\n      continue;\n    }\n\n    // otherwise, we have to inherit or use the default\n    hasInherit = true;\n\n    // default is StringParam\n    paramConfigMap[key] = options.params?.[key] ?? StringParam;\n  }\n\n  // if we didn't inherit anything, just return the input\n  if (!hasInherit) return paramConfigMapWithInherit as QueryParamConfigMap;\n\n  return paramConfigMap;\n}\n\n/**\n * Extends a config to include params for all specified keys,\n * defaulting to StringParam if not found in the inheritedParams\n * map.\n */\nexport function extendParamConfigForKeys(\n  baseParamConfigMap: QueryParamConfigMap,\n  paramKeys: string[],\n  inheritedParams?: QueryParamOptions['params'] | undefined,\n  defaultParam?: QueryParamConfig<any> | undefined\n) {\n  // if we aren't inheriting anything or there are no params, return the input\n  if (!inheritedParams || !paramKeys.length) return baseParamConfigMap;\n\n  let paramConfigMap = { ...baseParamConfigMap };\n  let hasInherit = false;\n  for (const paramKey of paramKeys) {\n    // if it is missing a parameter, fill it in\n    if (!Object.prototype.hasOwnProperty.call(paramConfigMap, paramKey)) {\n      paramConfigMap[paramKey] = inheritedParams[paramKey] ?? defaultParam;\n      hasInherit = true;\n    }\n  }\n\n  if (!hasInherit) return baseParamConfigMap;\n  return paramConfigMap;\n}\n", "/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license at\n * https://github.com/facebook/fbjs/blob/master/LICENSE\n */\n\n/*eslint-disable no-self-compare */\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any): boolean {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n\n * @pbeshai modification of shallowEqual to take into consideration a map providing\n * equals functions\n */\nexport default function shallowEqual(\n  objA: any,\n  objB: any,\n  equalMap?: any\n): boolean {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    const isEqual = equalMap?.[keysA[i]]?.equals ?? is;\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !isEqual(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {\n  DecodedValueMap,\n  EncodedQuery,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { DecodedParamCache } from './decodedParamCache';\nimport shallowEqual from './shallowEqual';\n\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nexport function getLatestDecodedValues<QPCMap extends QueryParamConfigMap>(\n  parsedParams: EncodedQuery,\n  paramConfigMap: QPCMap,\n  decodedParamCache: DecodedParamCache\n) {\n  const decodedValues: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // we have new encoded values, so let's get new decoded values.\n  // recompute new values but only for those that changed\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    // do we have a new encoded value?\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n\n    // if we have a new encoded value, re-decode. otherwise reuse cache\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n\n      // check if we had a cached value for this encoded value but a different encoder\n      // (sometimes people inline decode functions, e.g. withDefault...)\n      // AND we had a different equals check than ===\n      if (\n        paramConfig.equals &&\n        decodedParamCache.has(paramName, encodedValue)\n      ) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n\n      // do not cache undefined values\n      if (decodedValue !== undefined) {\n        decodedParamCache.set(\n          paramName,\n          encodedValue,\n          decodedValue,\n          paramConfig.decode\n        );\n      }\n    }\n\n    // in case the decode function didn't interpret `default` for some reason,\n    // we can interpret it here as a backup\n    if (decodedValue === undefined && paramConfig.default !== undefined) {\n      decodedValue = paramConfig.default;\n    }\n\n    decodedValues[paramName as keyof QPCMap] = decodedValue;\n  }\n\n  return decodedValues as DecodedValueMap<QPCMap>;\n}\n\n/**\n * Wrap get latest so we use the same exact object if the current\n * values are shallow equal to the previous.\n */\nexport function makeStableGetLatestDecodedValues() {\n  let prevDecodedValues: DecodedValueMap<any> | undefined;\n\n  function stableGetLatest<QPCMap extends QueryParamConfigMap>(\n    parsedParams: EncodedQuery,\n    paramConfigMap: QPCMap,\n    decodedParamCache: DecodedParamCache\n  ) {\n    const decodedValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n    if (\n      prevDecodedValues != null &&\n      shallowEqual(prevDecodedValues, decodedValues)\n    ) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n\n  return stableGetLatest;\n}\n", "import { EncodedValueMap, QueryParamConfigMap } from 'serialize-query-params';\n\n/**\n * Create an alias mapping using the optional `urlName` property on params\n */\nexport function serializeUrlNameMap(\n  paramConfigMap: QueryParamConfigMap\n): string | undefined {\n  let urlNameMapParts: string[] | undefined;\n  for (const paramName in paramConfigMap) {\n    if (paramConfigMap[paramName].urlName) {\n      const urlName = paramConfigMap[paramName].urlName;\n      const part = `${urlName}\\0${paramName}`;\n      if (!urlNameMapParts) urlNameMapParts = [part];\n      else urlNameMapParts.push(part);\n    }\n  }\n\n  return urlNameMapParts ? urlNameMapParts.join('\\n') : undefined;\n}\n\n/**\n * Converts the stringified alias/urlName map back into an object\n */\nexport function deserializeUrlNameMap(\n  urlNameMapStr: string | undefined\n): Record<string, string> | undefined {\n  if (!urlNameMapStr) return undefined;\n\n  return Object.fromEntries(\n    urlNameMapStr.split('\\n').map((part) => part.split('\\0'))\n  );\n}\n\n/**\n * converts { searchString: 'foo'} to { q: 'foo'} if the searchString\n * is configured to have \"q\" as its urlName.\n */\nexport function applyUrlNames(\n  encodedValues: Partial<EncodedValueMap<any>>,\n  paramConfigMap: QueryParamConfigMap\n) {\n  let newEncodedValues: Partial<EncodedValueMap<any>> = {};\n  for (const paramName in encodedValues) {\n    if (paramConfigMap[paramName]?.urlName != null) {\n      newEncodedValues[paramConfigMap[paramName].urlName!] =\n        encodedValues[paramName];\n    } else {\n      newEncodedValues[paramName] = encodedValues[paramName];\n    }\n  }\n\n  return newEncodedValues;\n}\n", "import { EncodedQuery } from 'serialize-query-params';\nimport shallowEqual from './shallowEqual';\nimport { deserializeUrlNameMap } from './urlName';\n\nlet cachedSearchString: string | undefined;\nlet cachedUrlNameMapString: string | undefined;\nlet cachedSearchStringToObjectFn:\n  | ((searchString: string) => EncodedQuery)\n  | undefined;\nlet cachedParsedQuery: EncodedQuery = {};\n\n/**\n * cached conversion of ?foo=1&bar=2 to { foo: '1', bar: '2' }\n */\nexport const memoSearchStringToObject = (\n  searchStringToObject: (searchString: string) => EncodedQuery,\n  searchString?: string | undefined,\n  /** optionally provide a mapping string to handle renames via `urlName`\n   * mapping are separated by \\n and mappings are urlName\\0paramName\n   */\n  urlNameMapStr?: string | undefined\n) => {\n  // if we have a cached version, just return it\n  if (\n    cachedSearchString === searchString &&\n    cachedSearchStringToObjectFn === searchStringToObject &&\n    cachedUrlNameMapString === urlNameMapStr\n  ) {\n    return cachedParsedQuery;\n  }\n\n  cachedSearchString = searchString;\n  cachedSearchStringToObjectFn = searchStringToObject;\n  const newParsedQuery = searchStringToObject(searchString ?? '');\n  cachedUrlNameMapString = urlNameMapStr;\n\n  const urlNameMap = deserializeUrlNameMap(urlNameMapStr);\n\n  // keep old values for keys if they are the same\n  for (let [key, value] of Object.entries(newParsedQuery)) {\n    // handle url name mapping\n    if (urlNameMap?.[key]) {\n      delete newParsedQuery[key];\n      key = urlNameMap[key];\n      newParsedQuery[key] = value;\n    }\n\n    const oldValue = cachedParsedQuery[key];\n    if (shallowEqual(value, oldValue)) {\n      newParsedQuery[key] = oldValue;\n    }\n  }\n\n  cachedParsedQuery = newParsedQuery;\n  return newParsedQuery;\n};\n", "import {\n  EncodedQuery,\n  QueryParamConfigMap,\n  searchStringToObject,\n  objectToSearchString,\n} from 'serialize-query-params';\nimport { UrlUpdateType } from './types';\n\nexport const defaultOptions: QueryParamOptionsWithRequired = {\n  searchStringToObject: searchStringToObject,\n  objectToSearchString: objectToSearchString,\n  updateType: 'pushIn',\n  includeKnownParams: undefined,\n  includeAllParams: false,\n  removeDefaultsFromUrl: false,\n  enableBatching: false,\n  skipUpdateWhenNoChange: true,\n};\n\nexport interface QueryParamOptions {\n  searchStringToObject?: (searchString: string) => EncodedQuery;\n  objectToSearchString?: (encodedParams: EncodedQuery) => string;\n  updateType?: UrlUpdateType;\n  includeKnownParams?: boolean;\n  includeAllParams?: boolean;\n  /** whether sets that result in no change to the location search string should be ignored (default: true) */\n  skipUpdateWhenNoChange?: boolean;\n  params?: QueryParamConfigMap;\n\n  /** when a value equals its default, do not encode it in the URL when updating */\n  removeDefaultsFromUrl?: boolean;\n\n  /**\n   * @experimental this is an experimental option to combine multiple `set` calls\n   * into a single URL update.\n   */\n  enableBatching?: boolean;\n}\n\ntype RequiredOptions = 'searchStringToObject' | 'objectToSearchString';\nexport type QueryParamOptionsWithRequired = Required<\n  Pick<QueryParamOptions, RequiredOptions>\n> &\n  Omit<QueryParamOptions, RequiredOptions>;\n\nexport function mergeOptions(\n  parentOptions: QueryParamOptionsWithRequired,\n  currOptions: QueryParamOptions | null | undefined\n): QueryParamOptionsWithRequired {\n  if (currOptions == null) {\n    currOptions = {};\n  }\n\n  const merged = { ...parentOptions, ...currOptions };\n\n  // deep merge param objects\n  if (currOptions.params && parentOptions.params) {\n    merged.params = { ...parentOptions.params, ...currOptions.params };\n  }\n\n  return merged;\n}\n", "import * as React from 'react';\nimport {\n  mergeOptions,\n  defaultOptions,\n  QueryParamOptions,\n  QueryParamOptionsWithRequired,\n} from './options';\nimport { QueryParamAdapter, QueryParamAdapterComponent } from './types';\n\n/**\n * Shape of the QueryParamContext, which the hooks consume to read and\n * update the URL state.\n */\ntype QueryParamContextValue = {\n  adapter: QueryParamAdapter;\n  options: QueryParamOptionsWithRequired;\n};\n\nconst providerlessContextValue: QueryParamContextValue = {\n  adapter: {} as QueryParamAdapter,\n  options: defaultOptions,\n};\n\nexport const QueryParamContext = React.createContext<QueryParamContextValue>(\n  providerlessContextValue\n);\n\nexport function useQueryParamContext() {\n  const value = React.useContext(QueryParamContext);\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    (value === undefined || value === providerlessContextValue)\n  ) {\n    throw new Error('useQueryParams must be used within a QueryParamProvider');\n  }\n\n  return value;\n}\n\n/**\n * Props for the Provider component, used to hook the active routing\n * system into our controls. Note only the root provider requires\n * `adapter`. We try to encourage that via intellisense by writing\n * the types this way (you must provide at least one of adapter or options,\n * default intellisense suggests adapter required.)\n */\ntype QueryParamProviderProps = {\n  /** Main app goes here */\n  children: React.ReactNode;\n} & (\n  | {\n      adapter?: never;\n      options: QueryParamOptions;\n    }\n  | {\n      /** required for the root provider but not for nested ones */\n      adapter: QueryParamAdapterComponent;\n      options?: QueryParamOptions;\n    }\n);\n\nfunction QueryParamProviderInner({\n  children,\n  adapter,\n  options,\n}: {\n  children: React.ReactNode;\n  adapter?: QueryParamAdapter | undefined;\n  options?: QueryParamOptions;\n}) {\n  // allow merging in parent options\n  const { adapter: parentAdapter, options: parentOptions } =\n    React.useContext(QueryParamContext);\n\n  const value = React.useMemo(() => {\n    return {\n      adapter: adapter ?? parentAdapter,\n      options: mergeOptions(\n        parentOptions,\n        options\n      ) as QueryParamOptionsWithRequired,\n    };\n  }, [adapter, options, parentAdapter, parentOptions]);\n\n  return (\n    <QueryParamContext.Provider value={value}>\n      {children}\n    </QueryParamContext.Provider>\n  );\n}\n\n/**\n * Context provider for query params to have access to the\n * active routing system, enabling updates to the URL.\n */\nexport function QueryParamProvider({\n  children,\n  adapter,\n  options,\n}: QueryParamProviderProps) {\n  const Adapter = adapter;\n  return Adapter ? (\n    <Adapter>\n      {(adapter) => (\n        <QueryParamProviderInner adapter={adapter} options={options}>\n          {children}\n        </QueryParamProviderInner>\n      )}\n    </Adapter>\n  ) : (\n    <QueryParamProviderInner options={options}>\n      {children}\n    </QueryParamProviderInner>\n  );\n}\n\nexport default QueryParamProvider;\n", "import { EncodedValueMap, QueryParamConfigMap } from 'serialize-query-params';\n\n/**\n * Note: This function is destructive - it mutates encodedValues.\n * Remove values that match the encoded defaults from the encodedValues object\n */\nexport function removeDefaults(\n  encodedValues: Partial<EncodedValueMap<any>>,\n  paramConfigMap: QueryParamConfigMap\n) {\n  for (const paramName in encodedValues) {\n    // does it have a configured default and does it have a non-undefined value?\n    if (\n      paramConfigMap[paramName]?.default !== undefined &&\n      encodedValues[paramName] !== undefined\n    ) {\n      // does its current value match the encoded default\n      const encodedDefault = paramConfigMap[paramName].encode(\n        paramConfigMap[paramName].default\n      );\n      if (encodedDefault === encodedValues[paramName]) {\n        encodedValues[paramName] = undefined;\n      }\n    }\n  }\n}\n", "import {\n  DecodedValueMap,\n  encodeQueryParams,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport { extendParamConfigForKeys } from './inheritedParams';\nimport { getLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { QueryParamOptionsWithRequired } from './options';\nimport { removeDefaults } from './removeDefaults';\nimport { PartialLocation, QueryParamAdapter, UrlUpdateType } from './types';\nimport { applyUrlNames } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\n/**\n * Given a ?foo=1&bar=2 and { bar: 3, baz: true } produce ?foo=1&bar=3&baz=1\n * or similar, depending on updateType. The result will be prefixed with \"?\"\n * or just be the empty string.\n */\nexport function getUpdatedSearchString({\n  changes,\n  updateType,\n  currentSearchString,\n  paramConfigMap: baseParamConfigMap,\n  options,\n}: {\n  changes: ChangesType<DecodedValueMap<any>>;\n  updateType?: UrlUpdateType;\n  currentSearchString: string;\n  paramConfigMap: QueryParamConfigMap;\n  options: QueryParamOptionsWithRequired;\n}): string {\n  const { searchStringToObject, objectToSearchString } = options;\n  if (updateType == null) updateType = options.updateType;\n\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(\n    searchStringToObject,\n    currentSearchString\n  );\n\n  // see if we have unconfigured params in the changes that we can\n  // inherit to expand our config map instead of just using strings\n  const paramConfigMap = extendParamConfigForKeys(\n    baseParamConfigMap,\n    Object.keys(changes),\n    options.params\n  );\n\n  // update changes prior to encoding to handle removing defaults\n  // getting latest values when functional update\n  let changesToUse: Partial<DecodedValueMap<any>>;\n\n  // functional updates here get the latest values\n  if (typeof changes === 'function') {\n    const latestValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n\n    changesToUse = (changes as Function)(latestValues);\n  } else {\n    // simple update here\n    changesToUse = changes;\n  }\n\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n\n  // remove defaults\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n\n  // interpret urlNames\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n\n  let newSearchString: string;\n  if (updateType === 'push' || updateType === 'replace') {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges,\n    });\n  }\n\n  if (newSearchString?.length && newSearchString[0] !== '?') {\n    (newSearchString as any) = `?${newSearchString}`;\n  }\n\n  return newSearchString ?? '';\n}\n\n/**\n * uses an adapter to update a location object and optionally\n * navigate based on the updateType\n */\nexport function updateSearchString({\n  searchString,\n  adapter,\n  navigate,\n  updateType,\n}: {\n  searchString: string;\n  adapter: QueryParamAdapter;\n  navigate: boolean;\n  updateType?: UrlUpdateType;\n}) {\n  const currentLocation = adapter.location;\n\n  // update the location and URL\n  const newLocation: PartialLocation = {\n    ...currentLocation,\n    search: searchString,\n  };\n\n  if (navigate) {\n    // be defensive about checking updateType since it is somewhat easy to\n    // accidentally pass a second argument to the setter.\n    if (typeof updateType === 'string' && updateType.startsWith('replace')) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\n\ntype UpdateArgs = Parameters<typeof getUpdatedSearchString>[0] & {\n  adapter: QueryParamAdapter;\n};\n\nconst immediateTask = (task: Function) => task();\nconst timeoutTask = (task: Function) => setTimeout(() => task(), 0);\n// alternative could be native `queueMicrotask`\n\nconst updateQueue: UpdateArgs[] = [];\n\n/**\n * support batching by enqueuing updates (if immediate is not true)\n */\nexport function enqueueUpdate(\n  args: UpdateArgs,\n  { immediate }: { immediate?: boolean } = {}\n) {\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n\n      let searchString: string | undefined;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate: UpdateArgs =\n          i === 0\n            ? updates[i]\n            : { ...updates[i], currentSearchString: searchString! };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n\n      // do not update unnecessarily #234\n      if (\n        args.options.skipUpdateWhenNoChange &&\n        searchString === initialSearchString\n      ) {\n        return;\n      }\n\n      updateSearchString({\n        searchString: searchString ?? '',\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType,\n      });\n    });\n  }\n}\n", "import * as React from 'react';\nimport { QueryParamConfigMap, DecodedValueMap } from 'serialize-query-params';\nimport useQueryParams from './useQueryParams';\nimport { SetQuery } from './types';\n\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\ntype Diff<T, K> = Omit<T, keyof K>;\n\nexport interface InjectedQueryProps<QPCMap extends QueryParamConfigMap> {\n  query: DecodedValueMap<QPCMap>;\n  setQuery: SetQuery<QPCMap>;\n}\n\n/**\n * HOC to provide query parameters via props `query` and `setQuery`\n * NOTE: I couldn't get type to automatically infer generic when\n * using the format withQueryParams(config)(component), so I switched\n * to withQueryParams(config, component).\n * See: https://github.com/microsoft/TypeScript/issues/30134\n */\nexport function withQueryParams<\n  QPCMap extends QueryParamConfigMap,\n  P extends InjectedQueryProps<QPCMap>\n>(paramConfigMap: QPCMap, WrappedComponent: React.ComponentType<P>) {\n  // return a FC that takes props excluding query and setQuery\n  const Component: React.FC<Diff<P, InjectedQueryProps<QPCMap>>> = (props) => {\n    const [query, setQuery] = useQueryParams(paramConfigMap);\n\n    // see https://github.com/microsoft/TypeScript/issues/28938#issuecomment-450636046 for why `...props as P`\n    return (\n      <WrappedComponent query={query} setQuery={setQuery} {...(props as any)} />\n    );\n  };\n  Component.displayName = `withQueryParams(${\n    WrappedComponent.displayName || WrappedComponent.name || 'Component'\n  })`;\n\n  return Component;\n}\n\nexport default withQueryParams;\n\n/**\n * HOC to provide query parameters via props mapToProps (similar to\n * react-redux connect style mapStateToProps)\n * NOTE: I couldn't get type to automatically infer generic when\n * using the format withQueryParams(config)(component), so I switched\n * to withQueryParams(config, component).\n * See: https://github.com/microsoft/TypeScript/issues/30134\n */\nexport function withQueryParamsMapped<\n  QPCMap extends QueryParamConfigMap,\n  MappedProps extends object,\n  P extends MappedProps\n>(\n  paramConfigMap: QPCMap,\n  mapToProps: (\n    query: DecodedValueMap<QPCMap>,\n    setQuery: SetQuery<QPCMap>,\n    props: Diff<P, MappedProps>\n  ) => MappedProps,\n  WrappedComponent: React.ComponentType<P>\n) {\n  // return a FC that takes props excluding query and setQuery\n  const Component: React.FC<Diff<P, MappedProps>> = (props) => {\n    const [query, setQuery] = useQueryParams(paramConfigMap);\n    const propsToAdd = mapToProps(query, setQuery, props);\n\n    // see https://github.com/microsoft/TypeScript/issues/28938#issuecomment-450636046 for why `...props as P`\n    return <WrappedComponent {...propsToAdd} {...(props as P)} />;\n  };\n  Component.displayName = `withQueryParams(${\n    WrappedComponent.displayName || WrappedComponent.name || 'Component'\n  })`;\n\n  return Component;\n}\n", "import { QueryParamConfigMap, DecodedValueMap } from 'serialize-query-params';\nimport useQueryParams from './useQueryParams';\nimport { SetQuery } from './types';\n\nexport interface QueryRenderProps<QPCMap extends QueryParamConfigMap> {\n  query: DecodedValueMap<QPCMap>;\n  setQuery: SetQuery<QPCMap>;\n}\n\nexport interface QueryParamsProps<QPCMap extends QueryParamConfigMap> {\n  config: QPCMap;\n  children: (renderProps: QueryRenderProps<QPCMap>) => JSX.Element;\n}\n\nexport const QueryParams = <QPCMap extends QueryParamConfigMap>({\n  config,\n  children,\n}: QueryParamsProps<QPCMap>) => {\n  const [query, setQuery] = useQueryParams(config);\n  return children({ query, setQuery });\n};\n\nexport default QueryParams;\n"],
  "mappings": "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",
  "names": ["import_react", "decodedParamCache", "searchStringToObject", "adapter", "searchStringToObject", "objectToSearchString", "setQuery", "adapter", "paramConfigMap", "options", "React"]
}
